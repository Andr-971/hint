
//! ⁡⁢⁣⁢ЦИКЛ «FOR»⁡
{
  // ⁡⁣⁣⁢Более сложный, но при этом самый распространённый цикл — цикл for. Обыкновенный цикл for имеет следующий синтаксис:⁡
  for (начало; условие; шаг) {
    // ⁡⁣⁢⁡⁢⁢⁢... тело цикла ...⁡
  }
  // ⁡⁣⁢⁡⁢⁢⁢Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:⁡
  for (let i = 0; i < 3; i++) { // ⁡⁣⁢⁡⁢⁢⁢выведет 0, затем 1, затем 2⁡
      alert(i);
  }
}
//! «FOR OF»⁡
{
  // ⁡⁣⁣⁡⁣⁣⁡⁣⁣⁢Оператор for...of выполняет цикл обхода итерируемых объектов (включая Array, Map, Set, объект аргументов и подобных), вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта. Работает с value.⁡
  // ⁡⁢⁢⁢Синтаксис:⁡
  for (переменная of итерабильный_объект) {
    заявление;
  }
  // ⁡⁢⁢⁢Например, чтобы пройтись по массиву и вывести его элементы, можно использовать следующий код:⁡
  let array = [10, 20, 30];
  // ⁡⁢⁢⁢В этом примере переменная value будет принимать значения 10, 20 и 30 на каждом шаге цикла.⁡
  for (let el of array) {
    el += 1; // ⁡⁢⁢⁢Увеличиваем значение на 1⁡
    console.log(el);
  } // ⁡⁢⁢⁢Вывод: 11, 21, 31⁡
}
//! «FOR AWAIT OF»⁡
{
  // ⁡⁣⁣⁢Выражение for await...of создаёт цикл, проходящий через асинхронные итерируемые объекты, а также синхронные итерируемые сущности, включающие: встроенные String, Array, Array-подобные объекты (например., arguments или NodeList), TypedArray, Map, Set, а также определяемые пользователем асинхронные/синхронные сущности. Он вызывает пользовательский итерационный хук с инструкциями, которые должны быть выполнены для значения каждого отдельного свойства объекта.⁡
  for await (переменная of итерабильный) {
    заявление;
  }
}
//! «FOR IN»⁡
{
  // ⁡⁣⁣⁡⁣⁣⁢Цикл for...in проходит только по перечисляемым свойствам. Объекты, созданные встроенными конструкторами, такими как Array и Object имеют неперечисляемые свойства от Object.prototype и String.prototype, например, от String-это indexOf(), а от Object - метод toString(). Цикл пройдёт по всем перечисляемым свойствам объекта, а также тем, что он унаследует от конструктора прототипа (свойства объекта в цепи прототипа). Работает и с key.⁡
  // ⁡⁢⁢⁢Cинтаксис:⁡
  for (переменная in объект) {
    заявление;
  }
  // ⁡⁢⁢⁢Например, чтобы пройтись по объекту и вывести его свойства, можно использовать следующий код:⁡
  let object = { a: 1, b: 2, c: 3 };
  for (let el in object) {
    console.log(el + " = " + object[el]);
    // ⁡⁢⁢⁢el ключи объекта⁡
    // ⁡⁢⁢⁢object[el] значение объекта⁡
  }
  // a = 1
  // b = 2
  // c = 3
}
//! ⁡⁢⁣⁢ЦИКЛ «WHILE»
{
  // ⁡⁣⁣⁢Цикл while имеет следующий синтаксис:⁡
  while (condition) {
    // код
    // также называемый "телом цикла"
  }
  // Код из тела цикла выполняется, пока условие condition истинно.
  // Например, цикл ниже выводит i, пока i < 3:
  let ind = 0;
  while (ind < 3) { // выводит 0, затем 1, затем 2
      alert( ind );
      i++;
  }
}
//! ⁡⁢⁣⁢ЦИКЛ «DO…WHILE»⁡
{
  // ⁡⁣⁣⁢Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:⁡
  do {
    // тело цикла
  } while (condition);
  // Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.
  // Например:
  let i = 0;
  do {
      alert( i );
      i++;
  } while (i < 3);
  // Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.
}